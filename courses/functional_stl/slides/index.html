<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css">
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"> -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <title>MAP586 - Functional programming</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section class="title">
        <h1>MAP 586</h1>
        <h2>Functional programming</h2>
      </section>

      <section>
        <section class="slide">
          <h1>Function definition</h1>
          <pre><code class="cpp">
double discount_factor(double rate, double maturity)
{
    double res = std::exp(-rate * maturity);
    return res;
}

void print_discount_factor(double rate, double maturity)
{
    double df = discount_factor(rate, maturity);
    std::cout &lt;&lt; "DF(" &lt;&lt; maturity &lt;&lt; "," &lt;&lt; rate &lt;&lt; ") = " &lt;&lt; df &lt;&lt; std::endl;
    // No return statement here
}
          </code></pre>
          <pre><code class="cpp fragment">
return_type function_name(arg1_type arg1_name, arg2_type arg2_name[,...])
{
    optional_return_statement;
}
          </code></pre>
        </section>

        <section>
            <h1>Arguments</h1>
          <p>The semantic of argument passing is the same as the semantic of initialization</p>
          <div class="fragment">
            <pre><code class="cpp">
double discount_factor(double rate, double maturity)
{
    return std::exp(-rate * maturity);
}

double df = discount_factor(0.04, 2);
            </code></pre>
          </div>
          <div class="fragment">
            <p>is equivalent to</p>
            <pre><code class="cpp">
double rate = 0.04;
double maturity = 2.5;
// jump to discount_factor code in memory
    return std::exp(-rate * maturity);
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Arguments</h1>
          <p>Type checking</p>
          <pre><code class="cpp">
double discount_factor(double rate, double maturity) { ... }
int main(int argc, char* argv[])
{
    const char* rate = "0.04";
    double r = 0.04;
    double m = 2.5;
    discount_factor(rate, m); // Error
    discount_factor(r, m);    // Ok
    return 0;
}
          </code></pre>
        </section>

        <section>
          <h1>Arguments</h1>
          <p>Arguments conversion</p>
          <pre><code class="cpp">
double discount_factor(double rate, double maturity) { ... }
int main(int argc, char* argv[])
{
    const char* rate = "0.04";
    double r = 0.04;
    int m = 2;
    discount_factor(rate, m); // Error
    discount_factor(r, m);    // Ok
    return 0;
}
          </code></pre>
        </section>

        <section>
          <h1>Arguments</h1>
          <p>Default argument</p>
          <div>
            <pre><code class="cpp">
double discount_factor(double rate, double maturity) { ... }
double d = discount_factor(0.04); // Error
            </code></pre>
          </div>
          <div class="fragment">
            <pre><code class="cpp">
double discount_factor(double rate, double maturity = 1.) { ... }
double d = discount_factor(0.04); // OK - Equivalent to discount_factor(0.04, 1.)
double d = discount_factor(0.04, 2.5) // OK, does not use the default argument
            </code></pre>
          </div>
          <div class="fragment">
            <pre><code class="cpp">
double discount_factor(double rate = 0.01, double maturity) { ... } // Illegal
double my_function(double a1, double a2 = 0., double a3) { ... }    // Illegal
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Return value</h1>
          <pre><code class="cpp">
double f1() { }             // Error: no return value
void   f2() { }             // OK
double f3() { return 1.2; } // OK
void   f4() { return 1.2; } // Error: void function
double f5() { return; }     // Error: missing return value
void   f6() { return; }     // OK
double f7() { return "7"; } // Error: wrong return type
double f8() { return 1; }   // OK: conversion from int to double
          </code></pre>
        </section>

        <section>
          <h1>Exercise</h1>
          <p>Open the notebook quicksort and follow the instructions</p>
        </section>
      </section>

      <section>
        <section>
          <h1>Reference</h1>
            <pre><code class="cpp">
void inc(int i1, int i2)
{
    ++i1;
    ++i2;
}

void client()
{
    int i = 4;
    int j = 5;
    inc(i, j);
    std::cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; std::endl;
    std::cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; std::endl;
}
          </code></pre>   
        </section>

        <section>
          <h1>Reference</h1>
          <pre><code class="cpp">
int i = 4;
int&amp; j = i;
++j;
std::cout &lt;&lt; i &lt;&lt; std::endl;
          </code></pre>
          <div class="fragment">
            <pre><code class="cpp">
int&amp; j; // Error: reference must be initialized
int i = 4;
int j&amp; = i;
int k = 8;
j = k;
++j;
std::cout &lt;&lt; i &lt;&lt; std::endl;
std::cout &lt;&lt; k &lt;&lt; std::endl;
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Reference</h1>
          <pre><code class="cpp">
void inc(int&amp; i1, int&amp; i2)
{
    ++i1;
    ++i2;
}

void client()
{
    int i = 4;
    int j = 5;
    inc(i, j);
    std::cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; std::endl;
    std::cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; std::endl;
}
          </code></pre>
        </section>

        <section>
          <h1>Const reference</h1>
          <pre><code class="cpp">
std::vector&lt;double&gt; discount_factor(std::vector&lt;double&gt;&amp; rate, std::vector&lt;double&gt;&amp; maturity)
{
    std::size_t size = rate.size();
    std::vector&lt;double&gt; res(size);
    for(size_t i = 0; i &lt; size; ++i)
    {
        rate[i] = std::exp(-rate[i] * maturity[i]); // Side-effect, the passed argument is changed!
    }
    return res;
}
          </code></pre>
        </section>

        <section>
          <h1>const reference</h1>
          <pre><code class="cpp">
std::vector&lt;double&gt; discount_factor(const std::vector&lt;double&gt;&amp; rate, const std::vector&lt;double&gt;&amp; maturity)
{
    std::size_t size = rate.size();
    std::vector&lt;double&gt; res(size);
    for(size_t i = 0; i &lt; size; ++i)
    {
        rate[i] = std::exp(-rate[i] * maturity[i]); // Error, cannot modify a const object
    }
    return res;
}
          </code></pre>
        </section>

        <section>
          <h1>const reference</h1>
          <pre><code class="cpp">
void discount_factor(const std::vector&lt;double&gt;&amp; rate, const std::vector&lt;double&gt;&amp; maturity,
                     std::vector&lt;double&gt;&amp; res)
{
    std::size_t size = rate.size();
    res.resize(size);
    for(size_t i = 0; i &lt; size; ++i)
    {
        res[i] = std::exp(-rate[i] * maturity[i]);
    }
}
          </code></pre>
        </section>
        <section>
          <h1>Exercise</h1>
          <p>Fix the quicksort implementation</p>
        </section>
      </section>

      <section>
        <section>
          <h1>Function overloading</h1>
          <pre><code class="cpp">
std::vector&lt;double&gt; discount_factor(const std::vector&lt;double&gt;&amp; rate, const std::vector&lt;double&gt;&amp; maturity);

int main(int argc, char* argv[])
{
    double df = discount_factor(0.04, 1.5); // error, cannot convert parameter 1 ...
    return 0;
}
          </code></pre>
          <div class="fragment">
            <pre><code class="cpp">
int main(int argc, char* argv[])
{
    std::vector&lt;double&gt; res = discount_factor(std::vector&lt;double&gt;(1, 0.04), std::vector&lt;double&gt;(1, 1.5));
    double df = res[0];
    return 0;
}
            </code></pre>
          </div>
        </section>

        <section>
          <h1>Function overloading</h1>
          <pre><code class="cpp">
std::vector&lt;double&gt; discount_factor(const std::vector&lt;double&gt;&amp; rate, const std::vector&lt;double&gt;&amp; maturity);
double discount_factor(double rate, double maturity);

int main(int argc, char* argv[])
{
    std::vector&lt;double&gt; r(3, 0.04);
    std::vector&lt;double&gt; m(3, 1.5);
    std::vector&lt;double&gt; df_vec = discount_factor(r, m);
    double df = discount_factor(0.04, 1.5);
    return 0;
}
          </code></pre>
        </section>

        <section>
          <h1>Function overloading</h1>
          <pre><code class="cpp">
void print(long);
void print(double);

void client()
{
    long l = 1L;
    double d = 1.5;
    int i = 1;
    print(l);         // Ok, calls print(long)
    print(d);         // Ok, calls print(double)
    print(i);         // Error, ambiguous
    print(long(i));   // Ok, calls print(long)
    print(double(i)); // Ok, calls print(double)
}
          </code></pre>
        </section>

        <section>
          <h1>Function overloading</h1>
          <pre><code class="cpp">
int    f(int, int);
void   f(int, int); // Illegal, overloaded function cannot differ only by return type
double f(double, double); // Ok
          </code></pre>
            <div class="fragment">
              <pre><code class="cpp">
int f(int, int);
// f's type     : int (int, int)
// f's signature: (int, int)
              </code></pre>
        </section>

      </section>
    </div>
  </div>
  <script type="module" src="/main.js"></script>
</body>

</html>
